# Methods

```{r setup-02}
source(here::here("validation/cs_process.R"))
source(here::here("validation/cs1_generate.R"))
source(here::here("validation/cs2_generate.R"))
```

## Data Processing

RNA was extracted from FFPE ovarian carcinoma samples and expression was quantified using NanoString nCounter. Samples were run in three CodeSets. Some samples or pools of samples were repeated across CodeSets for expression normalization. Normalizing CS2 to CS3 can easily follow the [PrOType](https://dchiu911.shinyapps.io/PrOType/) method for HGSC subtypes because both CodeSets have pool samples. A different technique is implemented when normalizing across CS1, CS2, and CS3 where we use common samples and genes as reference sets.

### Raw Data

NanoString CodeSets contained a mix of all probes of interest, six positive controls spiked-in at fixed proportional concentrations (0.125- 128 fM), and eight negative controls (probes without a corresponding target). Gene targets also included 5 housekeeping genes: POLR1B, SDHA, PGK1, ACTB, RPL19. Gene selection was made from top ranked differential gene expression analysis between ovarian cancer histotypes and molecular subtypes of HGSC, as well as containing some genes of interest from unrelated projects. Gene targets in each subsequent CodeSet were re-curated, where non-informative genes were dropped and new potential differentiating genes were added.

There are 3 NanoString CodeSets:

-   CS1: OvCa2103\_C953

    -   Samples = `r ncol(cs1) - 3`
    -   Genes = `r nrow(cs1)`

-   CS2: PrOTYPE2\_v2\_C1645

    -   Samples = `r ncol(cs2) - 3`
    -   Genes = `r nrow(cs2)`

-   CS3: OTTA2014\_C2822

    -   Samples = `r ncol(cs3) - 3`
    -   Genes = `r nrow(cs3)`

These datasets contain raw counts extracted straight from NanoString RCC files.

```{r setup-unique-venn-diagrams, include=FALSE}
library(VennDiagram)
futile.logger::flog.threshold(futile.logger::ERROR, name = "VennDiagramLogger")

cs1_id <- cs_common[which(cs_common$CS1 != 0 & !is.na(cs_common$CS1)),]
cs2_id <- cs_common[which(cs_common$CS2 != 0 & !is.na(cs_common$CS2)),]
cs3_id <- cs_common[which(cs_common$CS3 != 0 & !is.na(cs_common$CS3) & !is.na(cs_common$summaryID)),]

#venn diagram of overlap between CodeSet samples by summary ID
#does not include total count of duplicate samples
venn_id <- venn.diagram(
  x = list(cs1_id$summaryID, cs2_id$summaryID, cs3_id$summaryID),
  category.names = c("CodeSet1", "CodeSet2", "CodeSet3"),
  filename = NULL,
  output = TRUE,
  imagetype = "png",
  height = 400,
  width = 400,
  resolution = 300,
  compression = "lzw",
  lwd = 1,
  col = c("#440154ff", '#21908dff', '#fde725ff'),
  fill = c(alpha("#440154ff", 0.3),
           alpha('#21908dff', 0.3),
           alpha('#fde725ff', 0.3)),
  cex = 2,
  fontfamily = "sans",
  cat.cex = 1.5,
  cat.default.pos = "outer",
  cat.pos = c(-27, 27, 135),
  cat.dist = c(0.055, 0.055, 0.085),
  cat.fontfamily = "sans",
  rotation = 1
)

venn_genes <- venn.diagram(
  x = list(cs1_norm$Name, cs2_norm$Name, cs3_norm$Name),
  category.names = c("CodeSet1", "CodeSet2", "CodeSet3"),
  filename = NULL,
  output = TRUE,
  imagetype = "png",
  height = 400,
  width = 400,
  resolution = 300,
  compression = "lzw",
  lwd = 1,
  col = c("#440154ff", '#21908dff', '#fde725ff'),
  fill = c(alpha("#440154ff", 0.3),
           alpha('#21908dff', 0.3),
           alpha('#fde725ff', 0.3)),
  cex = 2,
  fontfamily = "sans",
  cat.cex = 1.5,
  cat.default.pos = "outer",
  cat.pos = c(-27, 27, 135),
  cat.dist = c(0.055, 0.055, 0.085),
  cat.fontfamily = "sans",
  rotation = 1
)
```

### Housekeeping Genes

The first normalization step is to normalize all endogenous genes to housekeeping genes (POLR1B, SDHA, PGK1, ACTB, RPL19; reference genes expressed in all cells). We normalize by subtracting the average log~2~ housekeeping gene expression from the log~2~ endogenous gene expression:

log~2~ endogenous expression - log~2~ average housekeeping expression = relative expression

The updated CodeSet dimensions are now:

-   CS1: OvCa2103\_C953

    -   Samples = `r ncol(cs1_norm) - 3`
    -   Genes = `r nrow(cs1_norm)`

-   CS2: PrOTYPE2\_v2\_C1645

    -   Samples = `r ncol(cs2_norm) - 3`
    -   Genes = `r nrow(cs2_norm)`

-   CS3: OTTA2014\_C2822

    -   Samples = `r ncol(cs3_norm) - 3`
    -   Genes = `r nrow(cs3_norm)`

The number of genes are reduced by 19: 5 housekeeping, 8 negative, 6 positive (the latter 2 types are not used).

### Common Samples and Genes

Since the reference pool samples only exist in CS2 and CS3, we need to find an alternative method to normalize all three CodeSets. One method is to select common samples and common genes that exist in all three. We found `r length(common_genes)` common genes. Using the `summaryID` identifier, we also found `r length(common_id)` common summary IDs, translating to `r length(common_samples)` samples. The number of samples that were matched to each CodeSet differed:

-   CS1: OvCa2103\_C953

    -   Samples = `r nrow(cs1_clean)`
    -   Genes = `r ncol(cs1_clean) - 2`

-   CS2: PrOTYPE2\_v2\_C1645

    -   Samples = `r nrow(cs2_clean)`
    -   Genes = `r ncol(cs2_clean) - 2`

-   CS3: OTTA2014\_C2822

    -   Samples = `r nrow(cs3_clean)`
    -   Genes = `r ncol(cs3_clean) - 2`

#### Overlap of common samples by summary ID

```{r venn-id}
grid.draw(venn_id)
```

#### Overlap of common genes

```{r venn-genes}
grid.draw(venn_genes)
```

\*Excluding housekeeping genes and controls

### CS1 Training Set Generation

We use the reference method to normalize CS1 to CS3.

-   CS1 reference set: duplicate samples from CS1

    -   Samples = `r nrow(cs1_ref2)`
    -   Genes = `r ncol(cs1_ref2)`

-   CS3 reference set: corresponding samples in CS3 also found in CS1 reference set

    -   Samples = `r nrow(cs3_ref)`
    -   Genes = `r ncol(cs3_ref)`

-   CS1 validation set: remaining CS1 samples with reference set removed

    -   Samples = `r nrow(cs1_val2)`
    -   Genes = `r ncol(cs1_val2)`

The final CS1 training set has `r nrow(cs1_data)` samples on `r ncol(cs1_data)` genes after normalization and keeping only the major histotypes of interest.

### CS2 Training Set Generation

We use the pool method to normalize CS2 to CS3 so we can be consistent with the PrOType normalization when there are available pools.

-   CS2 pools:

    -   Samples = 12 (Pool 1 = 4, Pool 2 = 4, Pool 3 = 4)
    -   Genes = `r nrow(cs2_pools)`

-   CS3 pools:

    -   Samples = `r ncol(ref_pools)` (Pool 1 = 12, Pool 2 = 5, Pool 3 = 5)
    -   Genes = `r nrow(ref_pools)`

-   CS2 validation set: CS2 samples with pools removed

    -   Samples = `r ncol(cs2_norm) - 3 - 9`
    -   Genes = `r nrow(cs2_norm)`

The final CS2 training set has `r nrow(cs2_data)` samples on `r ncol(cs2_data)` (common) genes after normalization and keeping only the major histotypes of interest.

### Cohort Distribution

CodeSets comprised samples from sites collected internationally as shown below. Note that the CS3 pools sample total (n=58) shown here include those that are not used as reference pools, following previous normalization methods. In particular, the distribution of CS3 pools actually used for normalization (n=22) is POOL1 = 12, POOL2 = 5, POOL3 = 5.

```{r cohort-dist}
source(here::here("validation/cs_process_cohorts.R"))
cohort_dist <- cohorts %>%
  filter(col_name %in% c(cs1_samples, cs2_samples, cs3_samples)) %>%
  count(file_source, cohort) %>%
  pivot_wider(names_from = "file_source", values_from = "n")

knitr::kable(cohort_dist,
             caption = "Cohort Distribution amongst CodeSets")
```

```{r cohort-dist-distinct}
cohort_dist_distinct <- cohorts %>%
  filter(col_name %in% c(cs1_samples, cs2_samples, cs3_samples)) %>% 
  distinct(ottaID, file_source, cohort) %>% 
  count(file_source, cohort) %>% 
  pivot_wider(names_from = "file_source", values_from = "n")

knitr::kable(cohort_dist_distinct,
             caption = "Distinct Cohort Distribution amongst CodeSets")
```

## Normalization Between CodeSets

After normalization to housekeeping genes and filtering for the five major histotypes of interest, as determined by pathology review and/or IHC, two methods were used to normalize data between CodeSets.

### Common Samples Method

The common samples method was used to normalize CodeSet1, 2, and 3, where common samples and genes were used as reference sets. Among the samples repeated in all CodeSets we normalized using either: a random set of 3 samples from each major histotype (random3; n=15), a random set of 2 samples from each major histotype (random2; n=10), or a random set of 1 sample from each major histotype (random1; n=5). In each case CodeSet3 expression (X~3~) was held fixed, while CodeSet1/2 expression (X~1~ and X~2~) were normalized to CodeSet3 by subtracting the average gene expression from the CodeSet1/2 reference set (R~1~ or R~2~) and adding the average gene expression of the CodeSet3 reference set (R~3~). Alternatively, X~1~ (norm) = X~1~ - R~1~ + R~3~ would calibrate CodeSet1 to CodeSet3.

### Pools Method

The pools method was used to normalize CodeSet2 and CodeSet3. The three reference pools, regularly assayed mixes of samples representing all histotypes, were run in CodeSet2 and CodeSet3 only. CodeSet2 contained 12 reference pool samples (Pool 1 = 4, Pool 2 = 4, Pool 3 = 4) and CodeSet3 contained 22 reference pool samples (Pool 1 = 12, Pool 2 = 5, Pool 3 = 5). Similar to the common samples method, CodeSet2 was normalized to CodeSet3 via: X~2~ (norm) = X~2~ - R~2~ + R~3~ where R is the average expression of the reference pool samples in the respective CodeSet. This method of pool normalization was also used by PrOType to classify HGSC subtypes

### Concordance Comparison

Concordance between CodeSets using the different normalization strategies was compared in common samples, excluding those used for the normalization, using Pearson's correlation coefficient (R^2^), coefficient of accuracy (Ca), and Lin's concordance correlation (Rc = R^2^ x Ca).

### Overlap of Common Samples in All CodeSets

```{r overlap-samples-all-venn, fig.width=8, fig.height=6}
annotNEW <- annotNEW %>%
  mutate(
    ottaID = gsub(".*_(.*)_[0-9]{2}$", "\\1", File.Name) %>%
      gsub("-N1$", "", .),
    CodeSet = recode_factor(
      geneRLF,
      OTTA2017_C6082 = "CS4",
      OTTA2018_C6830 = "CS5",
      OTTA2018_C8440 = "CS6"
    )
  )

cs4_exp <- filter(annotNEW, CodeSet == "CS4")
cs4_qc <- NanoStringQC(raw = cs4, exp = cs4_exp, detect = 50, sn = 170)
cs4_qc_failed <- filter(cs4_qc, normFlag == "Failed")[["File.Name"]]
cs4_dat <- HKnorm(cs4) %>% select(-any_of(cs4_qc_failed))

cs5_exp <- filter(annotNEW, CodeSet == "CS5")
cs5_qc <- NanoStringQC(raw = cs5, exp = cs5_exp, detect = 50, sn = 170)
cs5_qc_failed <- filter(cs5_qc, normFlag == "Failed", !grepl("POOL", File.Name))[["File.Name"]]
cs5_dat <- HKnorm(cs5) %>% select(-any_of(cs5_qc_failed))

annot_cs45 <- annotNEW %>%
  select(FileName = File.Name, ottaID, CodeSet) %>% 
  filter(!FileName %in% c(cs4_qc_failed, cs5_qc_failed))

annot_cs123 <- annot_cs %>% select(FileName, ottaID, CodeSet)

annot_full <- bind_rows(annot_cs123, annot_cs45)

common_cs_full <- annot_full %>%
  count(CodeSet, ottaID) %>%
  spread(CodeSet, n, fill = 0) %>%
  mutate(
    all_codesets = rowSums(.[, -1:-2])
  ) %>% 
  filter(!is.na(ottaID))

cs1_ottaID <- common_cs_full %>% filter(CS1 > 0) %>% pull(ottaID)
cs2_ottaID <- common_cs_full %>% filter(CS2 > 0) %>% pull(ottaID)
cs3_ottaID <- common_cs_full %>% filter(CS3 > 0) %>% pull(ottaID)
cs4_ottaID <- common_cs_full %>% filter(CS4 > 0) %>% pull(ottaID)
cs5_ottaID <- common_cs_full %>% filter(CS5 > 0) %>% pull(ottaID)

venn_ottaID <- venn.diagram(
  x = list(cs1_ottaID, cs2_ottaID, cs3_ottaID, cs4_ottaID, cs5_ottaID),
  category.names = c("CS1", "CS2", "CS3", "CS4", "CS5"),
  filename = NULL,
  output = TRUE,
  imagetype = "png",
  height = 400,
  width = 400,
  resolution = 300,
  compression = "lzw",
  lwd = 1,
  col = c("#440154ff", '#21908dff', '#fde725ff', 'orange', 'brown'),
  fill = c(alpha("#440154ff", 0.3),
           alpha('#21908dff', 0.3),
           alpha('#fde725ff', 0.3),
           alpha('orange', 0.3),
           alpha('brown', 0.3)),
  cex = 2,
  fontfamily = "sans",
  cat.cex = 1.5,
  cat.default.pos = "outer",
  cat.fontfamily = "sans"
)

grid.draw(venn_ottaID)
```

```{r overlap-samples-all-table}
overlap_samples_all <- common_cs_full %>% 
  select(CS1:CS5) %>% 
  mutate(across(.fns = ~ ifelse(. > 0, 1, 0))) %>% 
  count(CS1, CS2, CS3, CS4, CS5) %>% 
  mutate(n_overlap = rowSums(.[, 1:5])) %>% 
  arrange(desc(n_overlap)) %>% 
  select(-n_overlap)

overlap_samples_all %>% 
  kable(caption = "Overlapping Samples from All CodeSets")
```

### Overlap of Common Genes in All CodeSets

```{r overlap-all-genes-venn, fig.width=8, fig.height=6}
cs1_genes <- cs1_norm %>%
  filter(Code.Class == "Endogenous") %>%
  pull(Name)
cs2_genes <- cs2_norm %>%
  filter(Code.Class == "Endogenous") %>%
  pull(Name)
cs3_genes <- cs3_norm_van %>%
  filter(Code.Class == "Endogenous") %>%
  pull(Name)
cs4_genes <- cs4_dat %>% 
  filter(Code.Class == "Endogenous") %>% 
  pull(Name)
cs5_genes <- cs5_dat %>% 
  filter(Code.Class == "Endogenous") %>% 
  pull(Name)

venn_genes_all <- venn.diagram(
  x = list(cs1_genes, cs2_genes, cs3_genes, cs4_genes, cs5_genes),
  category.names = c("CS1", "CS2", "CS3", "CS4", "CS5"),
  filename = NULL,
  output = TRUE,
  imagetype = "png",
  height = 400,
  width = 400,
  resolution = 300,
  compression = "lzw",
  lwd = 1,
  col = c("#440154ff", '#21908dff', '#fde725ff', 'orange', 'brown'),
  fill = c(alpha("#440154ff", 0.3),
           alpha('#21908dff', 0.3),
           alpha('#fde725ff', 0.3),
           alpha('orange', 0.3),
           alpha('brown', 0.3)),
  cex = 2,
  fontfamily = "sans",
  cat.cex = 1.5,
  cat.default.pos = "outer",
  cat.fontfamily = "sans"
)

grid.draw(venn_genes_all)
```

```{r overlap-genes-all-table}
overlap_genes_all <-
  list(
    CS1 = cs1_genes,
    CS2 = cs2_genes,
    CS3 = cs3_genes,
    CS4 = cs4_genes,
    CS5 = cs5_genes
  ) %>%
  imap_dfr( ~ data.frame(CodeSet = .y, Gene = .x)) %>%
  count(CodeSet, Gene) %>%
  spread(CodeSet, n, fill = 0) %>%
  count(CS1, CS2, CS3, CS4, CS5) %>%
  mutate(n_overlap = rowSums(.[, 1:5])) %>%
  arrange(desc(n_overlap)) %>%
  select(-n_overlap)

overlap_genes_all %>% 
  kable(caption = "Overlapping Genes from All CodeSets")
```


## Histotype Classification

We use 5 classification algorithms and 4 subsampling methods across 500 repetitions in the supervised learning framework for the Training Set, CS1 and CS2. The pipeline was run using SLURM batch jobs submitted to a partition on a CentOS 7 server. Implementations of the techniques below were called from the [splendid](https://alinetalhouk.github.io/splendid/) package.

-   Classifiers:

    -   Random Forest
    -   SVM
    -   Adaboost
    -   Multinomial Regression Model with Ridge Penalty
    -   Multinomial Regression Model with LASSO Penalty

-   Subsampling:

    -   None
    -   Down-sampling
    -   Up-sampling
    -   SMOTE
