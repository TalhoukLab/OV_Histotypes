# Methods

```{r setup-02}
source(here::here("validation/cs_process.R"))
source(here::here("validation/cs1_generate.R"))
source(here::here("validation/cs2_generate.R"))
```

## Data Processing

Normalizing CS2 to CS3 can easily follow the PrOTYPE method for HGSC subtypes because both CodeSets have pool samples. A different technique is implemented when normalizing CS1 to CS3 where we use common samples and genes as reference sets.

### Raw Data

There are 3 NanoString CodeSets:

* CS1: OvCa2103_C953
  * Samples = `r ncol(cs1) - 3`
  * Genes = `r nrow(cs1)`
* CS2: PrOTYPE2_v2_C1645
  * Samples = `r ncol(cs2) - 3`
  * Genes = `r nrow(cs2)`
* CS3: OTTA2014_C2822
  * Samples = `r ncol(cs3) - 3`
  * Genes = `r nrow(cs3)`
  
These datasets contain raw counts extracted straight from NanoString RCC files.

### Housekeeping Genes

The first normalization step is to normalize all endogenous genes to housekeeping genes (POLR1B, SDHA, PGK1, ACTB, RPL19; reference genes expressed in all cells). We normalize by subtracting the average log~2~ housekeeping gene expression from the log~2~ endogenous gene expression. The updated CodeSet dimensions are now:

* CS1: OvCa2103_C953
  * Samples = `r ncol(cs1_norm) - 3`
  * Genes = `r nrow(cs1_norm)`
* CS2: PrOTYPE2_v2_C1645
  * Samples = `r ncol(cs2_norm) - 3`
  * Genes = `r nrow(cs2_norm)`
* CS3: OTTA2014_C2822
  * Samples = `r ncol(cs3_norm) - 3`
  * Genes = `r nrow(cs3_norm)`

The number of genes are reduced by 19: 5 housekeeping, 8 negative, 6 positive (the latter 2 types are not used).

### Common Samples and Genes

Since the reference pool samples only exist in CS2 and CS3, we need to find an alternative method to normalize all three CodeSets. One method is to select common samples and common genes that exist in all three. We found `r length(common_genes)` common genes. Using the `summaryID` identifer, we found `r length(common_id)` common summary IDs, which translated to `r length(common_samples)` samples. The number of samples that were found in each CodeSet differed:

* CS1: OvCa2103_C953
  * Samples = `r nrow(cs1_clean)`
  * Genes = `r ncol(cs1_clean) - 2`
* CS2: PrOTYPE2_v2_C1645
  * Samples = `r nrow(cs2_clean)`
  * Genes = `r ncol(cs2_clean) - 2`
* CS3: OTTA2014_C2822
  * Samples = `r nrow(cs3_clean)`
  * Genes = `r ncol(cs3_clean) - 2`
  
### CS1 Training Set Generation

We use the reference method to normalize CS1 to CS3.

* CS1 reference set: duplicate samples from CS1
  * Samples = `r nrow(cs1_ref2)`
  * Genes = `r ncol(cs1_ref2)`
* CS3 reference set: corresponding samples in CS3 also found in CS1 reference set
  * Samples = `r nrow(cs3_ref)`
  * Genes = `r ncol(cs3_ref)`
* CS1 validation set: remaining CS1 samples with reference set removed
  * Samples = `r nrow(cs1_val2)`
  * Genes = `r ncol(cs1_val2)`

The final CS1 training set has `r nrow(cs1_data)` samples on `r ncol(cs1_data)` genes after normalization and keeping only the major histotypes of interest.

### CS2 Training Set Generation

We use the pool method to normalize CS2 to CS3 so we can be consistent with the PrOTYPE normalization when there are available pools.

* CS3 pools:
  * Samples = `r ncol(ref_pools)`
  * Genes = `r nrow(ref_pools)`
* CS2 pools:
  * Samples = `r ncol(cs2_pools)`
  * Genes = `r nrow(cs2_pools)`

The final CS2 training set has `r nrow(cs2_data)` samples on `r ncol(cs2_data)` (common) genes after normalization
and keeping ony the major histotypes of interest.

## Classification

We use 5 classification algorithms and 4 subsampling methods across 500 repetitions in the supervised learning framework for CS1.

- Classifiers:
  - Random Forest
  - Adaboost
  - LDA
  - SVM
  - K-Nearest Neighbours
- Subsampling:
  - None
  - Down-sampling
  - Up-sampling
  - SMOTE
